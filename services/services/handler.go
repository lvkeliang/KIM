package services

import (
	"KIM/communication"
	"KIM/container"
	"KIM/logger"
	"KIM/protocol"
	"KIM/protocol/protoImpl"
	"KIM/services"
	"bytes"
	"github.com/golang/protobuf/proto"
	"github.com/prometheus/common/log"
	"time"
)

type ServHandler struct {
	r          *services.Router
	cache      services.SessionStorage
	dispatcher *services.DispatcherImpl
}

func (h *ServHandler) Disconnect(id string) error {
	logger.Warnf("close event of %s", id)
	return nil
}

func NewServHandler(r *services.Router, cache services.SessionStorage) *ServHandler {
	return &ServHandler{
		r:          r,
		dispatcher: &services.DispatcherImpl{},
		cache:      cache,
	}
}

// Accept 逻辑服务接收handshake
// 在逻辑服务如chat中，读取gateway发过来的消息，并且把req.ServiceId当作ChannelId返回
func (h *ServHandler) Accept(conn protocol.Conn, timeout time.Duration) (string, error) {
	_ = conn.SetReadDeadline(time.Now().Add(timeout))
	frame, err := conn.ReadFrame()
	if err != nil {
		return "", err
	}

	var req protoImpl.InnerHandshakeReq
	_ = proto.Unmarshal(frame.GetPayload(), &req)
	log.Info("Accept -- ", req.ServiceId)
	return req.ServiceId, nil
}

// Receive 逻辑服务接收消息
func (h *ServHandler) Receive(ag communication.Agent, payload []byte) {
	buf := bytes.NewBuffer(payload)
	packet, err := protocol.MustUnMarshalLogicPkt(buf)
	if err != nil {
		log.Error(err)
		return
	}
	var session *protoImpl.Session
	if packet.Command == protocol.CommandLoginSignIn {
		// 如果是登录包，就自动生成一个Session
		server, _ := packet.GetSpecificMeta(protocol.MetaDestServer)
		session = &protoImpl.Session{
			ChannelId: packet.ChannelId,
			GateId:    server.(string),
			Tags:      []string{"AutoGenerated"},
		}
	} else {
		//如果不是登录包，则从会话管理中读取一个会话对象，如果不存在则返回ErrSessionNi错误，表示需要重新建立连接并登录
		// TODO：优化点
		session, err = h.cache.Get(packet.ChannelId)
		if err == services.ErrSessionNil {
			_ = RespErr(ag, packet, protoImpl.Status_SessionNotFound)
			return
		} else if err != nil {
			_ = RespErr(ag, packet, protoImpl.Status_SystemException)
			return
		}
	}
	log.Debugf("recv a message from %s  %s", session, &packet.Header)
	err = h.r.Serve(packet, h.dispatcher, h.cache, session)
	if err != nil {
		log.Warn(err)
	}
}

func RespErr(ag communication.Agent, p *protocol.LogicPkt, status protoImpl.Status) error {
	packet := protocol.NewLogicPktFromHeader(&p.Header)
	packet.Status = status
	packet.Flag = protoImpl.Flag_Response

	packet.AddStringMeta(protocol.MetaDestChannels, p.Header.ChannelId)
	return container.Push(ag.ID(), packet)
}
