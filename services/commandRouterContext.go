package services

import (
	"KIM/logger"
	"KIM/protocol"
	"KIM/protocol/protoImpl"
	"KIM/util"
	"bytes"
	"errors"
	"github.com/golang/protobuf/proto"
	"sync"
)

var ErrSessionNil = errors.New("err:session nil")

type SessionStorage interface {
	Add(session *protoImpl.Session) error
	Delete(account string, channelId string) error
	Get(channelId string) (*protoImpl.Session, error)
	GetLocations(accounts ...string) ([]*Location, error)         //批量获取位置信息,主要用于群聊时读取群成员定位信息
	GetLocation(account string, device string) (*Location, error) //获取某个账号的信息，device作为预留参数，用于支持多设备登录
}

type Session interface {
	GetChannelId() string
	GetGateId() string
	GetAccount() string
	GetRemoteIP() string
	GetApp() string
	GetTags() []string
}

type RouterContext interface {
	Dispatcher //消息分发器，用于推送消息到网关
	SessionStorage
	Header() *protoImpl.Header
	ReadBody(val proto.Message) error
	Session() Session //用于存储/查询会话信息
	RespWithError(status protoImpl.Status, err error) error

	Resp(status protoImpl.Status, body proto.Message) error    // 向发送方返回响应（如ACK确认或业务响应）
	Dispatch(body proto.Message, receivers ...*Location) error //向其他接收方推送消息（如单聊/群聊消息的转发），派发消息给指定的接收方Location
}

// Location location表示一个用户的位置，通过网关ID和ChannelId可以定位
type Location struct {
	ChannelId string
	GateId    string
}

func (loc *Location) Bytes() []byte {
	if loc == nil {
		return []byte{}
	}
	buf := new(bytes.Buffer)
	_ = util.WriteShortBytes(buf, []byte(loc.ChannelId))
	_ = util.WriteShortBytes(buf, []byte(loc.GateId))
	return buf.Bytes()
}

func (loc *Location) Unmarshal(data []byte) (err error) {
	if len(data) == 0 {
		return errors.New("data is empty")
	}
	buf := bytes.NewBuffer(data)
	loc.ChannelId, err = util.ReadShortString(buf)
	if err != nil {
		return
	}
	loc.GateId, err = util.ReadShortString(buf)
	if err != nil {
		return
	}
	return
}

// HandlerFunc defines the handler used
type HandlerFunc func(ctx RouterContext)

// HandlersChain HandlersChain
type HandlersChain []HandlerFunc

type RouterContextImpl struct {
	sync.Mutex
	Dispatcher
	SessionStorage

	handlers HandlersChain
	index    int
	packet   *protocol.LogicPkt
	session  Session
}

func NewRouterContext() RouterContext {
	return &RouterContextImpl{}
}

func (c *RouterContextImpl) reset() {
	c.packet = nil
	c.index = 0
	c.handlers = nil
	c.session = nil
}

func (c *RouterContextImpl) Header() *protoImpl.Header {
	return &c.packet.Header
}

func (c *RouterContextImpl) ReadBody(val proto.Message) error {
	return c.packet.ReadBody(val)
}

func (c *RouterContextImpl) Session() Session {
	if c.session == nil {
		server, _ := c.packet.GetSpecificMeta(protocol.MetaDestServer)
		c.session = &protoImpl.Session{
			ChannelId: c.packet.ChannelId,
			GateId:    server.(string),
			Tags:      []string{"AutoGenerated"},
		}
	}
	return c.session
}

func (c *RouterContextImpl) RespWithError(status protoImpl.Status, err error) error {
	return c.Resp(status, &protoImpl.ErrorResp{Message: err.Error()})
}

// Dispatch 向其他接收方推送消息（如单聊/群聊消息的转发），派发消息给指定的接收方Location
func (c *RouterContextImpl) Dispatch(body proto.Message, receivers ...*Location) error {
	if len(receivers) == 0 {
		return nil
	}
	packet := protocol.CopyLogicPktHeader(c.Header())
	packet.Flag = protoImpl.Flag_Push
	packet.WriteBody(body)

	logger.Debugf("<-- Dispatch to %d users command:%s", len(receivers), &c.packet.Header)

	// 将接收方按照gateway分组
	group := make(map[string][]string)
	for _, receiver := range receivers {
		// 如果消息是从发送方来的，那么不必再向发送方推送，因为发送方本来就有这条消息
		if receiver.ChannelId == c.Session().GetChannelId() {
			continue
		}
		if _, ok := group[receiver.GateId]; !ok {
			group[receiver.GateId] = make([]string, 0)
		}
		group[receiver.GateId] = append(group[receiver.GateId], receiver.ChannelId)
	}

	for gateway, groupedReceivers := range group {
		err := c.Push(gateway, groupedReceivers, packet)
		if err != nil {
			logger.Error(err)
			return err
		}
	}
	return nil
}

// Resp 向发送方返回响应（如ACK确认或业务响应）
func (c *RouterContextImpl) Resp(status protoImpl.Status, body proto.Message) error {
	packet := protocol.CopyLogicPktHeader(c.Header())
	packet.Status = status
	packet.WriteBody(body)
	packet.Flag = protoImpl.Flag_Response
	logger.Debugf("<-- Resp to %s command:%s status: %v body: %s", c.session.GetAccount(), &c.packet.Header, status, body)

	err := c.Push(c.Session().GetGateId(), []string{c.Session().GetChannelId()}, packet)
	if err != nil {
		logger.Error(err)
		return err
	}
	return nil
}

func (c *RouterContextImpl) Next() {
	if c.index >= len(c.handlers) {
		return
	}

	handler := c.handlers[c.index]
	c.index++
	if handler == nil {
		logger.Warn("arrived unknown HandlerFunc")
		return
	}
	handler(c)
}
